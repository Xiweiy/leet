##NOT MYSQL, COULD BE TERADATA SQL
SELECT SALARY
FROM (
    SELECT SALARY, RANK() OVER (PARTITION BY ID ORDER SALARY DESC) AS SRANK
    FROM Employee) AS A
WHERE SRANK = 2
;

##MYSQL
SELECT ( ##ADDITIONAL LAYER OF SELECT ONLY TO ENSURE EXTRACTING NULL WHEN THEIR IS ACTUALLY EMPTY
    SELECT SALARY
    FROM (
        SELECT SALARY, @ROWNAME := @ROWNAME +1 AS SRANK
        FROM Employee, (SELECT @ROWNAME:=0) AS R
        ORDER BY SALARY DESC
    ) AS A
    WHERE SRANK =2) AS SecondHighestSalary
;
##THIS SOLUTION IS SIMILAR TO THE PREVIOUS ONE, @ROWNAME PLAY THE FUNCTION OF RANK()
##BUT THIS SOLUTION HAS PROBLEM THIS TIED HIGHEST SALARY
##PROBABLY RANK FUNCTION IS NOT GOOD AT HANDLING TIE SITUATIONS

##ADDING GROUP BY 
SELECT (
    SELECT SALARY
    FROM (
        SELECT SALARY, @ROWNAME := @ROWNAME +1 AS SRANK
        FROM (SELECT SALARY FROM Employee GROUP BY SALARY) AS S, (SELECT @ROWNAME:=0) AS R
        ORDER BY SALARY DESC
    ) AS A
    WHERE SRANK =2) AS SecondHighestSalary
;


##SOLUTION 2: No need for UserDefinedVariable
SELECT max(Salary) as SecondHighestSalary
FROM Employee
WHERE Salary < (SELECT max(Salary) FROM Employee)


SELECT max(Salary) as SecondHighestSalary
From Employee
WHERE Salary not in (SELECT max(Salary) FROM Employee )

Note: use max() can ensure returning null when it does not exist


##SOLUTION 3: USE OFFSET
select (
  select distinct Salary from Employee order by Salary Desc limit 1 offset 1
)as SecondHighestSalary
